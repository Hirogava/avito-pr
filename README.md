# Сервис назначения ревьюеров для Pull Request’ов

## Описание Проекта

Этот репозиторий содержит реализацию **Сервиса назначения ревьюеров для Pull Request’ов (PR)**, разработанного в рамках тестового задания для стажёра Backend (осенняя волна 2025) от Avito.

Сервис представляет собой микросервис с HTTP API, предназначенный для автоматического назначения ревьюеров на Pull Request’ы из команды автора, управления командами и активностью пользователей, а также для выполнения переназначения ревьюверов.

### Основные Сущности и Правила

| Сущность | Описание | Ключевые Правила |
| :--- | :--- | :--- |
| **Пользователь (User)** | Участник команды с уникальным ID, именем и флагом активности `isActive`. | Неактивный пользователь (`isActive = false`) не может быть назначен ревьювером. |
| **Команда (Team)** | Группа пользователей с уникальным именем. | Ревьюеры назначаются только из команды автора PR. |
| **Pull Request (PR)** | Сущность с ID, названием, автором, статусом (`OPEN` / `MERGED`) и списком ревьюверов. | Назначается **до двух** активных ревьюверов, исключая автора. После `MERGED` изменение списка ревьюверов **запрещено**. |
| **Назначение** | Автоматическое назначение ревьюверов при создании PR. | Выбираются случайные активные участники из команды автора (до 2-х). |
| **Переназначение** | Замена одного ревьювера. | Заменяет ревьювера на случайного **активного** участника **из команды заменяемого** ревьювера. |
| **Merge** | Изменение статуса PR на `MERGED`. | Операция должна быть **идемпотентной**. |

## Технический Стек

| Категория | Технология | Примечание |
| :--- | :--- | :--- |
| **Язык Программирования** | Go (Golang) | Выбран как предпочтительный язык согласно условиям задания. |
| **Фреймворк** | Gin | Используется для реализации HTTP API. |
| **База Данных** | PostgreSQL | Выбран как предпочтительный вариант для хранения данных. |
| **ORM/Driver** | `database/sql` (встроенный) + `pgx` | Прямое взаимодействие с БД через `pgx` для контроля и производительности. |
| **Контейнеризация** | Docker, Docker Compose | Для простого развертывания сервиса и его зависимостей. |
| **Миграции** | `golang-migrate/migrate` | Для управления схемой базы данных. |
| **Линтер** | `golangci-lint` | Для проверки формата кода. |

## Запуск Проекта

Проект разработан с учетом требования о запуске одной командой `docker-compose up`.

### Требования

Для запуска проекта необходимы:
1. **Docker**
2. **Docker Compose**

### Быстрый запуск

1. **Клонируйте репозиторий:**
   ```bash
   git clone https://github.com/Hirogava/avito-pr.git
   cd avito-pr
   ```

2. **Создайте файл окружения `.env`:**
   Скопируйте пример и заполните необходимые переменные (например, для подключения к PostgreSQL).
   ```bash
   # Пример содержимого .env
   DB_USER=avito_user
   DB_PASSWORD=avito_password
   DB_NAME=avito_pr_db
   DB_CONNECT_STRING=postgres://postgres:password@localhost:5432/dbname?sslmode=disable
   SERVER_PORT=:8080
   ```

3. **Используйте команду `make docker-up`**

4. **Получите доступы:**
   Для работы с защищенными эндпоинтами (например, `/pullRequest/*`) требуется аутентификация. В качестве примера пользователя с ролью `"admin"` используется следующая модель:

   1. Сделайте запрос на `/users` для получения всех юзеров и проектов (на проекте миграции с сид датой) 
      **Пример ответа эндпоинта `/users` (GET):**
      ```json
      {
         "users": [
            {
                  "user_id": "38c08664-357e-471e-b15b-8ba0547c2e34",
                  "username": "admin_backend",
                  "team_name": "backend",
                  "is_active": true
            },
            {
                  "user_id": "242e8920-deeb-4403-b03e-8430e455556f",
                  "username": "alice",
                  "team_name": "backend",
                  "is_active": true
            }
         ]
      }
      ```

   2. Сделайте запрос на `/auth/admin` с айди пользователя (одного из) и флагом `is_admin`, если true, то пользователь будет админом и ему доступны все эндпоинты. Вернется с него refresh, access токены, айди пользователя. Access токен в последующем везде нужно вставлять в заголовок Authorization Bearer (реализована кастомная JWT система)
      **Пример запроса на эндпоинт `/auth/admin` (POST):**
      ```json
      {
         "user_id" : "38c08664-357e-471e-b15b-8ba0547c2e34",
         "is_admin" : true
      }
      ```
      **Пример ответа эндпоинта `/auth/admin` (POST):**
      ```json
      {
         "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjMxMTQwNDksImlkIjoiMzhjMDg2NjQtMzU3ZS00NzFlLWIxNWItOGJhMDU0N2MyZTM0Iiwicm9sZSI6ImFkbWluIn0.yfuW4qZ9OJXB_o03Hm85p5WJDJAz47rLE9dBOh62RDw",
         "refresh_token": "f27f7509-13c8-4d86-9da4-fe889e8a4489",
         "role": "admin",
         "userID": "38c08664-357e-471e-b15b-8ba0547c2e34"
      }
      ```

   3. **Пробуйте :D**

   4. **Остановка сервиса:**
      ```bash
      docker-compose down
      ```

### Команды `Makefile`

Для удобства разработки и управления проектом предусмотрены следующие команды:

| Команда | Описание |
| :--- | :--- |
| `make lint` | Проверка проекта линтером |
| `make build` | Сборка исполняемого файла Go. |
| `make run` | Сборка и запуск приложения локально. |
| `make clean` | Удаление собранных файлов. |
| `make docker-build` | Сборка Docker-образа приложения. |
| `make docker-up` | Запуск сервисов через Docker Compose (аналогично `docker-compose up -d`). |
| `make docker-down` | Остановка и удаление сервисов через Docker Compose. |
| `make migrate-up` | Применение всех непримененных миграций. |
| `make migrate-down` | Откат последней примененной миграции. |

## API Эндпоинты

Сервис реализует следующие основные группы эндпоинтов:

| Группа | Эндпоинт | Метод | Описание |
| :--- | :--- | :--- | :--- |
| **Auth** | `/auth/admin` | `POST` | Установка роли пользователю (переменной is_admin). |
| **Team** | `/team/add` | `POST` | Создание новой команды. |
| **Team** | `/team/get` | `GET` | Получение информации о команде. |
| **Users** | `/users` | `GET` | Получение списка всех пользователей. |
| **Users** | `/users/setIsActive` | `POST` | Активация/деактивация пользователя. |
| **Users** | `/users/getReview` | `GET` | Получение списка PR, назначенных пользователю на ревью. |
| **Pull Request** | `/pullRequest/create` | `POST` | Создание PR и автоматическое назначение ревьюверов. |
| **Pull Request** | `/pullRequest/merge` | `POST` | Изменение статуса PR на `MERGED` (идемпотентно). |
| **Pull Request** | `/pullRequest/reassign` | `POST` | Переназначение ревьювера. |

**Примечание:** Все эндпоинты, кроме `/auth/admin`, защищены middleware-функцией, требующей аутентификации (`middleware.AuthMiddleware`). В текущей реализации, для операций с PR и установки флага активного пользователя (SetIsActive) требуется роль `"admin"`.

## Ход Решения и Допущения

В процессе реализации были сделаны следующие ключевые архитектурные и логические решения:

### 1. Структура Проекта
Использована стандартная структура Go-проекта с разделением на слои:
*   `cmd/pr/main.go`: Точка входа в приложение.
*   `internal/transport/http`: Роутинг и HTTP-сервер.
*   `internal/handlers`: Обработчики HTTP-запросов (логика валидации запросов и вызов сервисного слоя).
*   `internal/repository/postgres`: Слой доступа к данным (PostgreSQL).
*   `internal/models`: Структуры данных (запросы, ответы, модели БД).

### 2. Реализация Логики Назначения Ревьюверов

*   **Автоматическое назначение (CreatePR):**
    *   При создании PR сервис находит всех **активных** пользователей в команде автора, исключая самого автора.
    *   Из этого списка выбираются **до двух** случайных пользователей.
    *   Для обеспечения случайности используется функция `rand.Shuffle` из стандартной библиотеки Go.
*   **Переназначение (ReassignPRAuthor):**
    *   Сервис находит команду заменяемого ревьювера.
    *   Находит всех **активных** пользователей в этой команде.
    *   Выбирает случайного пользователя, который не является автором PR и не является уже назначенным ревьювером.
    *   Проверяется условие: если PR уже `MERGED`, переназначение запрещено.
*   **Идемпотентность Merge:**
    *   Эндпоинт `/pullRequest/merge` реализован таким образом, что повторный вызов для уже `MERGED` PR не приводит к ошибке, а возвращает актуальное состояние PR, что соответствует требованию идемпотентности.

### 3. Вопросы и Допущения

В соответствии с требованием о предоставлении допущений, сделанных при отсутствии явных указаний в задании:

| Вопрос/Проблема | Допущение и Обоснование |
| :--- | :--- |
| **Аутентификация и Авторизация** | **Допущение:** Реализована простая аутентификация с использованием токенов (JWT или аналоги), и для операций с PR (создание, merge, переназначение) и установки флага активности требуется роль `"admin"`. **Обоснование:** В задании не была предоставлена спецификация `openapi.yaml`, поэтому пришлось самостоятельно определить минимально необходимый набор эндпоинтов для управления пользователями/командами и PR. Требование роли `"admin"` было введено для имитации защищенного API. |
| **Случайность выбора ревьюверов** | **Допущение:** Для выбора случайных ревьюверов достаточно использовать стандартный пакет `math/rand` с перемешиванием списка кандидатов. **Обоснование:** Для тестового задания это является достаточным уровнем "случайности". |
| **Обработка ошибок** | **Допущение:** Введены кастомные ошибки для слоя БД (`dbErrors`), которые затем обрабатываются в слое `handlers` для возврата соответствующих HTTP-статусов (например, `404 Not Found`, `400 Bad Request`). **Обоснование:** Четкое разделение ошибок помогает в отладке и обеспечивает более информативные ответы API. |
